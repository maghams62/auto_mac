"""
Folder Agent - LLM-driven folder management with security guardrails.

This agent provides folder management capabilities:
- List folder contents
- Plan folder reorganization (dry-run)
- Apply reorganization plans (with confirmation)
- Security validation (sandbox enforcement)

The LLM decides which tools to use and in what order based on user intent.
"""

from typing import Dict, Any, List, Optional
from langchain_core.tools import tool
import logging

logger = logging.getLogger(__name__)


@tool
def folder_list(folder_path: Optional[str] = None) -> Dict[str, Any]:
    """
    List contents of a folder (non-recursive, alphabetically sorted).

    FOLDER AGENT - LEVEL 1: Discovery
    Use this as the first step to understand current folder structure.

    This is a read-only operation that shows all files and folders
    in the specified directory. Returns items sorted alphabetically.

    Args:
        folder_path: Path to list (defaults to primary document directory from config)

    Returns:
        Dictionary with items (list), total_count (int), folder_path (str)
        Each item includes: name, type (file/dir), size, modified, extension

    Security:
        - All paths validated against sandbox (configured document folders)
        - Symlinks resolved and validated
        - Parent directory traversal (..) rejected
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_list(folder_path='{folder_path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.list_folder(folder_path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_list: {e}")
        return {
            "error": True,
            "error_type": "ListError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_plan_alpha(folder_path: Optional[str] = None) -> Dict[str, Any]:
    """
    Generate a plan to normalize folder/file names alphabetically.

    FOLDER AGENT - LEVEL 2: Planning (DRY-RUN)
    Use this to preview changes before applying them.

    This is a read-only operation that proposes normalized names:
    - Lowercase
    - Spaces converted to underscores
    - Special characters removed
    - Multiple underscores collapsed

    NO files are modified. This is always a dry-run.

    Args:
        folder_path: Path to analyze (defaults to primary document directory from config)

    Returns:
        Dictionary with:
        - plan: List of proposed changes (current_name, proposed_name, reason)
        - needs_changes: Boolean indicating if any changes are needed
        - total_items: Total number of items analyzed
        - changes_count: Number of items that need renaming

    Security:
        - All paths validated against sandbox
        - No write operations performed
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_plan_alpha(folder_path='{folder_path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.plan_folder_organization_alpha(folder_path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_plan_alpha: {e}")
        return {
            "error": True,
            "error_type": "PlanError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_apply(
    plan: List[Dict[str, Any]],
    folder_path: Optional[str] = None,
    dry_run: bool = True
) -> Dict[str, Any]:
    """
    Apply a folder reorganization plan (atomic renames).

    FOLDER AGENT - LEVEL 3: Execution (WRITE OPERATION)
    Use this ONLY after getting user confirmation on the plan.

    This performs actual file/folder renames based on a plan
    generated by folder_plan_alpha.

    IMPORTANT: Always use dry_run=True first to validate, then
    get user confirmation before setting dry_run=False.

    Args:
        plan: List of rename operations from folder_plan_alpha
        folder_path: Base folder path (defaults to sandbox root)
        dry_run: If True, validate but don't execute (default: True)

    Returns:
        Dictionary with:
        - success: Boolean indicating if all operations succeeded
        - applied: List of successfully renamed items
        - skipped: List of items that didn't need changes
        - errors: List of items that failed with error messages
        - dry_run: Boolean indicating if this was a dry run

    Security:
        - All paths validated against sandbox
        - Each rename validated before execution
        - Conflicts detected (destination exists)
        - Atomic operations (no partial renames)

    Error Handling:
        - Conflicts: Destination already exists -> skip with error
        - Locked files: OS-level lock -> skip with error
        - Invalid paths: Outside sandbox -> skip with error
        - Missing source: File doesn't exist -> skip with error
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_apply(dry_run={dry_run}, plan_items={len(plan)})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.apply_folder_plan(plan, folder_path, dry_run)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_apply: {e}")
        return {
            "error": True,
            "error_type": "ApplyError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_organize_by_type(
    folder_path: Optional[str] = None,
    dry_run: bool = True
) -> Dict[str, Any]:
    """
    Group files into subfolders based on file extension (e.g., PDF, TXT).

    FOLDER AGENT - LEVEL 3: Type-Based Organization
    Use this when the user requests "organize by file type" or similar.

    Behavior:
    - Looks at top-level files in the specified folder (defaults to sandbox root)
    - Creates one folder per extension (e.g., PDF/, TXT/, NO_EXTENSION/)
    - Moves each file into its matching folder
    - Respects dry_run flag for preview vs execution

    Args:
        folder_path: Folder to organize (defaults to sandbox root)
        dry_run: If True, only generate plan (default). Set False after confirmation.

    Returns:
        Dictionary with plan, summary, and optional applied moves

    Security:
        - Validates sandbox boundaries
        - Skips hidden files and directories
        - Avoids overwriting existing files (skips with reason)
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_organize_by_type(folder_path='{folder_path}', dry_run={dry_run})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.organize_by_file_type(folder_path, dry_run=dry_run)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_organize_by_type: {e}")
        return {
            "error": True,
            "error_type": "OrganizeByTypeError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_find_duplicates(
    folder_path: Optional[str] = None,
    recursive: bool = False
) -> Dict[str, Any]:
    """
    Find duplicate files by content hash (SHA-256).

    FOLDER AGENT - LEVEL 2: Analysis (READ-ONLY)
    Use this when user asks to find, list, or identify duplicate files.

    This is a read-only operation that identifies files with identical
    content by computing SHA-256 hashes. Files are grouped by hash,
    and the tool reports wasted disk space.

    Behavior:
    - Compares files by content (not just name or size)
    - Groups duplicates together with metadata
    - Calculates wasted disk space
    - Can search recursively or just top-level

    Args:
        folder_path: Path to analyze (defaults to primary document directory from config)
        recursive: Search subdirectories (default: False, top-level only)

    Returns:
        Dictionary with:
        - duplicates: List of duplicate groups (hash, size, count, files)
        - total_duplicate_files: Total count of duplicate files
        - total_duplicate_groups: Number of duplicate groups
        - wasted_space_bytes: Total bytes wasted
        - wasted_space_mb: Wasted space in MB

    Security:
        - All paths validated against sandbox
        - No write operations performed
        - Skips hidden files and directories

    Example workflow:
    1. User: "Find duplicate files in my folder"
    2. Agent: folder_find_duplicates(folder_path=None, recursive=False)
    3. Agent: Summarize results and present to user
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_find_duplicates(folder_path='{folder_path}', recursive={recursive})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.find_duplicates(folder_path, recursive)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_find_duplicates: {e}")
        return {
            "error": True,
            "error_type": "DuplicateDetectionError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_summarize(folder_path: Optional[str] = None, items: Optional[List[Dict[str, Any]]] = None) -> Dict[str, Any]:
    """
    Generate comprehensive folder overview with statistics and insights.

    FOLDER AGENT - LEVEL 2: Analysis (READ-ONLY)
    Use this to provide users with natural language summaries of folder contents.

    This tool analyzes file types, sizes, dates, and generates actionable insights
    about the folder's contents and potential organization improvements.

    Args:
        folder_path: Path to analyze (defaults to sandbox root)
        items: Pre-fetched folder items (optional, avoids redundant listing)

    Returns:
        Dictionary with:
        - summary: Natural language overview
        - statistics: Quantitative data (counts, sizes, distributions)
        - insights: Key observations about the folder
        - recommendations: Actionable suggestions

    Security:
        - All paths validated against sandbox
        - No write operations performed
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_summarize(folder_path='{folder_path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.summarize_folder(folder_path, items)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_summarize: {e}")
        return {
            "error": True,
            "error_type": "SummaryError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_sort_by(
    folder_path: Optional[str] = None,
    items: Optional[List[Dict[str, Any]]] = None,
    criteria: str = "name",
    direction: str = "ascending"
) -> Dict[str, Any]:
    """
    Sort folder contents by specified criteria with explanation.

    FOLDER AGENT - LEVEL 2: Analysis (READ-ONLY)
    Use this when users want to view files in a specific order.

    Supported criteria: name, date, size, type, extension

    Args:
        folder_path: Path to analyze (defaults to sandbox root)
        items: Pre-fetched folder items (optional)
        criteria: Sort criteria (name|date|size|type|extension)
        direction: Sort direction (ascending|descending)

    Returns:
        Dictionary with:
        - sorted_items: Sorted file list
        - criteria: Sort criteria used
        - direction: Sort direction used
        - explanation: Why this sorting is useful
        - insights: Key observations from the sorted view

    Security:
        - All paths validated against sandbox
        - No write operations performed
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_sort_by(criteria='{criteria}', direction='{direction}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.sort_folder_by(folder_path, items, criteria, direction)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_sort_by: {e}")
        return {
            "error": True,
            "error_type": "SortError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_explain_file(file_path: str) -> Dict[str, Any]:
    """
    Explain file content and purpose using metadata and semantic analysis.

    FOLDER AGENT - LEVEL 2: Analysis (READ-ONLY) with Cross-Agent Integration
    Use this when users want to understand what a specific file contains.

    This tool combines file metadata with content analysis from the file agent
    to provide comprehensive explanations of files.

    Args:
        file_path: Path to the file to explain

    Returns:
        Dictionary with:
        - explanation: Natural language file description
        - key_topics: Main topics/content areas
        - suggested_actions: Recommended next steps
        - content_summary: Brief content overview

    Security:
        - File path validated against sandbox
        - No write operations performed
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_explain_file(file_path='{file_path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.explain_file(file_path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_explain_file: {e}")
        return {
            "error": True,
            "error_type": "ExplainError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_archive_old(
    folder_path: Optional[str] = None,
    items: Optional[List[Dict[str, Any]]] = None,
    age_threshold_days: int = 180,
    dry_run: bool = True
) -> Dict[str, Any]:
    """
    Archive old files to reduce folder clutter.

    FOLDER AGENT - LEVEL 3: Execution (WRITE OPERATION)
    Use this to move old/unused files to timestamped archive folders.

    Args:
        folder_path: Source folder path (defaults to sandbox root)
        items: Pre-fetched folder items (optional)
        age_threshold_days: Files older than this many days will be archived
        dry_run: If True, only show plan (default: True, requires confirmation)

    Returns:
        Dictionary with archive plan or execution results:
        - archive_plan: What will be archived (dry_run=True)
        - files_moved: Successfully archived files (dry_run=False)
        - archive_created: Archive folder path
        - space_freed_mb: Space recovered

    Security:
        - All paths validated against sandbox
        - Files are moved, not deleted
        - Atomic operations with rollback on failure
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_archive_old(age_threshold={age_threshold_days}, dry_run={dry_run})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.archive_old_files(folder_path, items, age_threshold_days, dry_run)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_archive_old: {e}")
        return {
            "error": True,
            "error_type": "ArchiveError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_organize_by_category(
    folder_path: Optional[str] = None,
    items: Optional[List[Dict[str, Any]]] = None,
    categorization: Optional[Dict[str, Any]] = None,
    dry_run: bool = True
) -> Dict[str, Any]:
    """
    Organize files into semantic categories based on content analysis.

    FOLDER AGENT - LEVEL 3: Execution (WRITE OPERATION) with Cross-Agent Integration
    Use this for intelligent content-based file organization.

    This tool uses content analysis to group files by topics/themes
    and creates category folders automatically.

    Args:
        folder_path: Source folder path (defaults to sandbox root)
        items: Pre-fetched folder items (optional)
        categorization: Pre-computed categorization results (optional)
        dry_run: If True, only show plan (default: True, requires confirmation)

    Returns:
        Dictionary with organization plan or execution results:
        - categories: Semantic categories and file assignments
        - new_structure: Proposed folder structure
        - folders_created: New category folders
        - files_moved: Successfully organized files

    Security:
        - All paths validated against sandbox
        - Atomic operations with rollback on failure
        - Cross-agent calls for content analysis
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_organize_by_category(dry_run={dry_run})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.organize_by_category(folder_path, items, categorization, dry_run)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_organize_by_category: {e}")
        return {
            "error": True,
            "error_type": "OrganizeByCategoryError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_check_sandbox(path: str) -> Dict[str, Any]:
    """
    Verify a path is within the allowed sandbox.

    FOLDER AGENT - LEVEL 0: Security Validation
    Use this to verify scope before operations.

    This validates that a given path is within the configured
    sandbox directory (configured document folders). All folder tools
    perform this check internally, but you can call this explicitly
    to verify scope or show the user the sandbox boundaries.

    Args:
        path: Path to validate

    Returns:
        Dictionary with:
        - is_safe: Boolean indicating if path is within sandbox
        - message: Human-readable explanation
        - resolved_path: Absolute path after resolving symlinks
        - allowed_folder: The configured sandbox root

    Security:
        - Resolves symlinks to prevent symlink attacks
        - Checks for parent directory traversal (..)
        - Validates against configured sandbox root
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_check_sandbox(path='{path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.check_sandbox(path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_check_sandbox: {e}")
        return {
            "error": True,
            "error_type": "ValidationError",
            "error_message": str(e),
            "retry_possible": False
        }


# Folder Agent Tool Registry
FOLDER_AGENT_TOOLS = [
    folder_check_sandbox,     # Level 0: Security
    folder_list,              # Level 1: Discovery
    folder_summarize,         # Level 2: Analysis (Summary & insights)
    folder_sort_by,           # Level 2: Analysis (Sorting with explanation)
    folder_explain_file,      # Level 2: Analysis (File explanation with cross-agent)
    folder_find_duplicates,   # Level 2: Analysis (Duplicate detection)
    folder_plan_alpha,        # Level 2: Planning (Normalization)
    folder_apply,             # Level 3: Execution (Renames)
    folder_organize_by_type,  # Level 3: Execution (Type-based moves)
    folder_archive_old,       # Level 3: Execution (Archive old files)
    folder_organize_by_category,  # Level 3: Execution (Semantic grouping)
]


# Folder Agent Hierarchy
FOLDER_AGENT_HIERARCHY = """
Folder Agent - Expanded Capabilities
===================================

LEVEL 0: Security Validation
└─ folder_check_sandbox → Verify path within sandbox

LEVEL 1: Discovery
└─ folder_list → List folder contents (non-recursive, sorted)

LEVEL 2: Analysis & Planning (Read-only)
├─ folder_summarize → Generate folder overview and statistics
├─ folder_sort_by → Sort files by criteria with explanation
├─ folder_explain_file → Explain file content and purpose (cross-agent)
├─ folder_find_duplicates → Detect content-based duplicates
└─ folder_plan_alpha → Generate normalization plan (no writes)

LEVEL 3: Execution (Write Operations)
├─ folder_apply → Apply rename plan (requires confirmation)
├─ folder_organize_by_type → Group files by extension
├─ folder_archive_old → Move old files to archive folders
└─ folder_organize_by_category → Semantic grouping by content

Cross-Agent Integration:
├─ File Agent: search_documents, extract_section (for content analysis)
├─ Email Agent: compose_email (for reports and summaries)
└─ Writing Agent: synthesize_content (for detailed analysis)

Expanded Workflow:
1. [Optional] folder_check_sandbox(path) → Verify scope
2. folder_list(folder_path) → Get current state
3. folder_summarize/folder_sort_by/folder_explain_file → Analyze contents
4. folder_plan_alpha/folder_find_duplicates → Plan changes
5. [USER CONFIRMATION REQUIRED] → Show preview
6. folder_apply/folder_organize_by_type/folder_archive_old → Execute
7. [Optional] Cross-agent: email results or create reports
8. [Optional] folder_list(folder_path) → Show final state

Security Invariants (Unchanged):
- All operations sandboxed to configured document folders
- Symlinks resolved and validated
- Parent directory traversal rejected
- Write operations require explicit dry_run=False
"""


class FolderAgent:
    """
    Folder Agent - LLM-driven folder management.

    Responsibilities:
    - List folder contents
    - Plan folder reorganization
    - Apply reorganization plans
    - Enforce sandbox security

    This agent is designed for LLM-first workflows where the LLM
    decides which tools to use based on user intent.
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.tools = {tool.name: tool for tool in FOLDER_AGENT_TOOLS}
        logger.info(f"[FOLDER AGENT] Initialized with {len(self.tools)} tools")

    def get_tools(self) -> List:
        """Get all folder agent tools."""
        return FOLDER_AGENT_TOOLS

    def get_hierarchy(self) -> str:
        """Get folder agent hierarchy documentation."""
        return FOLDER_AGENT_HIERARCHY

    def execute(self, tool_name: str, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a folder agent tool."""
        if tool_name not in self.tools:
            return {
                "error": True,
                "error_type": "ToolNotFound",
                "error_message": f"Folder agent tool '{tool_name}' not found",
                "available_tools": list(self.tools.keys())
            }

        tool = self.tools[tool_name]
        logger.info(f"[FOLDER AGENT] Executing: {tool_name}")

        try:
            result = tool.invoke(inputs)
            return result
        except Exception as e:
            logger.error(f"[FOLDER AGENT] Execution error: {e}")
            return {
                "error": True,
                "error_type": "ExecutionError",
                "error_message": str(e),
                "retry_possible": False
            }
