"""
Folder Agent - LLM-driven folder management with security guardrails.

This agent provides folder management capabilities:
- List folder contents
- Plan folder reorganization (dry-run)
- Apply reorganization plans (with confirmation)
- Security validation (sandbox enforcement)

The LLM decides which tools to use and in what order based on user intent.
"""

from typing import Dict, Any, List, Optional
from langchain_core.tools import tool
import logging

logger = logging.getLogger(__name__)


@tool
def folder_list(folder_path: Optional[str] = None) -> Dict[str, Any]:
    """
    List contents of a folder (non-recursive, alphabetically sorted).

    FOLDER AGENT - LEVEL 1: Discovery
    Use this as the first step to understand current folder structure.

    This is a read-only operation that shows all files and folders
    in the specified directory. Returns items sorted alphabetically.

    Args:
        folder_path: Path to list (defaults to sandbox root: test_data)

    Returns:
        Dictionary with items (list), total_count (int), folder_path (str)
        Each item includes: name, type (file/dir), size, modified, extension

    Security:
        - All paths validated against sandbox (test_data by default)
        - Symlinks resolved and validated
        - Parent directory traversal (..) rejected
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_list(folder_path='{folder_path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.list_folder(folder_path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_list: {e}")
        return {
            "error": True,
            "error_type": "ListError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_plan_alpha(folder_path: Optional[str] = None) -> Dict[str, Any]:
    """
    Generate a plan to normalize folder/file names alphabetically.

    FOLDER AGENT - LEVEL 2: Planning (DRY-RUN)
    Use this to preview changes before applying them.

    This is a read-only operation that proposes normalized names:
    - Lowercase
    - Spaces converted to underscores
    - Special characters removed
    - Multiple underscores collapsed

    NO files are modified. This is always a dry-run.

    Args:
        folder_path: Path to analyze (defaults to sandbox root: test_data)

    Returns:
        Dictionary with:
        - plan: List of proposed changes (current_name, proposed_name, reason)
        - needs_changes: Boolean indicating if any changes are needed
        - total_items: Total number of items analyzed
        - changes_count: Number of items that need renaming

    Security:
        - All paths validated against sandbox
        - No write operations performed
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_plan_alpha(folder_path='{folder_path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.plan_folder_organization_alpha(folder_path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_plan_alpha: {e}")
        return {
            "error": True,
            "error_type": "PlanError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_apply(
    plan: List[Dict[str, Any]],
    folder_path: Optional[str] = None,
    dry_run: bool = True
) -> Dict[str, Any]:
    """
    Apply a folder reorganization plan (atomic renames).

    FOLDER AGENT - LEVEL 3: Execution (WRITE OPERATION)
    Use this ONLY after getting user confirmation on the plan.

    This performs actual file/folder renames based on a plan
    generated by folder_plan_alpha.

    IMPORTANT: Always use dry_run=True first to validate, then
    get user confirmation before setting dry_run=False.

    Args:
        plan: List of rename operations from folder_plan_alpha
        folder_path: Base folder path (defaults to sandbox root)
        dry_run: If True, validate but don't execute (default: True)

    Returns:
        Dictionary with:
        - success: Boolean indicating if all operations succeeded
        - applied: List of successfully renamed items
        - skipped: List of items that didn't need changes
        - errors: List of items that failed with error messages
        - dry_run: Boolean indicating if this was a dry run

    Security:
        - All paths validated against sandbox
        - Each rename validated before execution
        - Conflicts detected (destination exists)
        - Atomic operations (no partial renames)

    Error Handling:
        - Conflicts: Destination already exists -> skip with error
        - Locked files: OS-level lock -> skip with error
        - Invalid paths: Outside sandbox -> skip with error
        - Missing source: File doesn't exist -> skip with error
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_apply(dry_run={dry_run}, plan_items={len(plan)})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.apply_folder_plan(plan, folder_path, dry_run)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_apply: {e}")
        return {
            "error": True,
            "error_type": "ApplyError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_organize_by_type(
    folder_path: Optional[str] = None,
    dry_run: bool = True
) -> Dict[str, Any]:
    """
    Group files into subfolders based on file extension (e.g., PDF, TXT).

    FOLDER AGENT - LEVEL 3: Type-Based Organization
    Use this when the user requests "organize by file type" or similar.

    Behavior:
    - Looks at top-level files in the specified folder (defaults to sandbox root)
    - Creates one folder per extension (e.g., PDF/, TXT/, NO_EXTENSION/)
    - Moves each file into its matching folder
    - Respects dry_run flag for preview vs execution

    Args:
        folder_path: Folder to organize (defaults to sandbox root)
        dry_run: If True, only generate plan (default). Set False after confirmation.

    Returns:
        Dictionary with plan, summary, and optional applied moves

    Security:
        - Validates sandbox boundaries
        - Skips hidden files and directories
        - Avoids overwriting existing files (skips with reason)
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_organize_by_type(folder_path='{folder_path}', dry_run={dry_run})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.organize_by_file_type(folder_path, dry_run=dry_run)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_organize_by_type: {e}")
        return {
            "error": True,
            "error_type": "OrganizeByTypeError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_find_duplicates(
    folder_path: Optional[str] = None,
    recursive: bool = False
) -> Dict[str, Any]:
    """
    Find duplicate files by content hash (SHA-256).

    FOLDER AGENT - LEVEL 2: Analysis (READ-ONLY)
    Use this when user asks to find, list, or identify duplicate files.

    This is a read-only operation that identifies files with identical
    content by computing SHA-256 hashes. Files are grouped by hash,
    and the tool reports wasted disk space.

    Behavior:
    - Compares files by content (not just name or size)
    - Groups duplicates together with metadata
    - Calculates wasted disk space
    - Can search recursively or just top-level

    Args:
        folder_path: Path to analyze (defaults to sandbox root: test_data)
        recursive: Search subdirectories (default: False, top-level only)

    Returns:
        Dictionary with:
        - duplicates: List of duplicate groups (hash, size, count, files)
        - total_duplicate_files: Total count of duplicate files
        - total_duplicate_groups: Number of duplicate groups
        - wasted_space_bytes: Total bytes wasted
        - wasted_space_mb: Wasted space in MB

    Security:
        - All paths validated against sandbox
        - No write operations performed
        - Skips hidden files and directories

    Example workflow:
    1. User: "Find duplicate files in my folder"
    2. Agent: folder_find_duplicates(folder_path=None, recursive=False)
    3. Agent: Summarize results and present to user
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_find_duplicates(folder_path='{folder_path}', recursive={recursive})")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.find_duplicates(folder_path, recursive)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_find_duplicates: {e}")
        return {
            "error": True,
            "error_type": "DuplicateDetectionError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def folder_check_sandbox(path: str) -> Dict[str, Any]:
    """
    Verify a path is within the allowed sandbox.

    FOLDER AGENT - LEVEL 0: Security Validation
    Use this to verify scope before operations.

    This validates that a given path is within the configured
    sandbox directory (test_data by default). All folder tools
    perform this check internally, but you can call this explicitly
    to verify scope or show the user the sandbox boundaries.

    Args:
        path: Path to validate

    Returns:
        Dictionary with:
        - is_safe: Boolean indicating if path is within sandbox
        - message: Human-readable explanation
        - resolved_path: Absolute path after resolving symlinks
        - allowed_folder: The configured sandbox root

    Security:
        - Resolves symlinks to prevent symlink attacks
        - Checks for parent directory traversal (..)
        - Validates against configured sandbox root
    """
    logger.info(f"[FOLDER AGENT] Tool: folder_check_sandbox(path='{path}')")

    try:
        from src.automation.folder_tools import FolderTools
        from src.utils import load_config

        config = load_config()
        tools = FolderTools(config)

        result = tools.check_sandbox(path)
        return result

    except Exception as e:
        logger.error(f"[FOLDER AGENT] Error in folder_check_sandbox: {e}")
        return {
            "error": True,
            "error_type": "ValidationError",
            "error_message": str(e),
            "retry_possible": False
        }


# Folder Agent Tool Registry
FOLDER_AGENT_TOOLS = [
    folder_check_sandbox,  # Level 0: Security
    folder_list,           # Level 1: Discovery
    folder_find_duplicates,  # Level 2: Analysis (Duplicate detection)
    folder_plan_alpha,     # Level 2: Planning
    folder_apply,          # Level 3: Execution (Renames)
    folder_organize_by_type,  # Level 3: Execution (Type-based moves)
]


# Folder Agent Hierarchy
FOLDER_AGENT_HIERARCHY = """
Folder Agent Hierarchy:
======================

LEVEL 0: Security Validation
└─ folder_check_sandbox → Verify path is within sandbox

LEVEL 1: Discovery
└─ folder_list → List folder contents (non-recursive, alphabetically sorted)

LEVEL 2: Planning (Dry-run)
└─ folder_plan_alpha → Generate normalization plan (no writes)

LEVEL 3: Execution (Write Operations)
├─ folder_apply → Apply rename plan (requires confirmation)
└─ folder_organize_by_type → Group files into extension-based subfolders (dry-run first!)

Typical Workflow:
1. [Optional] folder_check_sandbox(path) → Verify scope
2. folder_list(folder_path) → Show current state
3. folder_plan_alpha(folder_path) → Generate plan (dry-run)
4. [USER CONFIRMATION REQUIRED]
5. folder_apply(plan, dry_run=True) → Validate plan
6. [USER CONFIRMATION REQUIRED]
7. folder_apply(plan, dry_run=False) → Execute renames
8. [Optional] folder_organize_by_type(folder_path, dry_run=True/False) → Extension-based organization

Security Invariants:
- All operations sandboxed to configured folder (test_data by default)
- Symlinks resolved and validated
- Parent directory traversal rejected
- Write operations require explicit dry_run=False
"""


class FolderAgent:
    """
    Folder Agent - LLM-driven folder management.

    Responsibilities:
    - List folder contents
    - Plan folder reorganization
    - Apply reorganization plans
    - Enforce sandbox security

    This agent is designed for LLM-first workflows where the LLM
    decides which tools to use based on user intent.
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.tools = {tool.name: tool for tool in FOLDER_AGENT_TOOLS}
        logger.info(f"[FOLDER AGENT] Initialized with {len(self.tools)} tools")

    def get_tools(self) -> List:
        """Get all folder agent tools."""
        return FOLDER_AGENT_TOOLS

    def get_hierarchy(self) -> str:
        """Get folder agent hierarchy documentation."""
        return FOLDER_AGENT_HIERARCHY

    def execute(self, tool_name: str, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a folder agent tool."""
        if tool_name not in self.tools:
            return {
                "error": True,
                "error_type": "ToolNotFound",
                "error_message": f"Folder agent tool '{tool_name}' not found",
                "available_tools": list(self.tools.keys())
            }

        tool = self.tools[tool_name]
        logger.info(f"[FOLDER AGENT] Executing: {tool_name}")

        try:
            result = tool.invoke(inputs)
            return result
        except Exception as e:
            logger.error(f"[FOLDER AGENT] Execution error: {e}")
            return {
                "error": True,
                "error_type": "ExecutionError",
                "error_message": str(e),
                "retry_possible": False
            }
