"""
Notes Agent - Handles Apple Notes creation and management.

This agent is responsible for:
- Creating new notes in Apple Notes
- Appending content to existing notes
- Organizing notes into folders
- Retrieving note content

INTEGRATION PATTERN:
- Notes are used for persistent storage of information
- Content can be generated by Writing Agent before saving
- Notes can store synthesis results, reports, or structured data
- Conditional note creation based on LLM reasoning (e.g., "if sunny, note sunglasses")

Acts as a persistent storage layer for information.
"""

from typing import Dict, Any, Optional
from langchain_core.tools import tool
import logging

logger = logging.getLogger(__name__)


@tool
def create_note(
    title: str,
    body: str,
    folder: str = "Notes"
) -> Dict[str, Any]:
    """
    Create a new note in Apple Notes.

    NOTES AGENT - LEVEL 1: Note Creation
    Use this to persistently store information generated by other agents.

    Args:
        title: Note title
        body: Note content/body text (can be multi-line)
        folder: Target folder name (default: "Notes")
                Falls back to default Notes folder if specified folder doesn't exist

    Returns:
        Dictionary with creation status:
        {
            "success": True,
            "note_title": str,
            "note_id": str,
            "folder": str,
            "created_at": str,  # ISO format timestamp
            "message": str
        }

    Example Workflow (Conditional Note Creation):
        Step 0: get_weather_forecast(location="LA", timeframe="today")
        Step 1: synthesize_content(
            source_contents=["$step0.current_conditions"],
            topic="Is it sunny outside?",
            synthesis_style="brief"
        )
        Step 2: IF $step1 says "sunny" -> create_note(
            title="Reminder for tomorrow",
            body="Weather is sunny today. Remember to bring sunglasses tomorrow.",
            folder="Personal"
        )

    INTEGRATION WITH WRITING AGENT:
    - Use synthesize_content or create_quick_summary to generate note body
    - Store reports, summaries, or analysis results in notes
    - Notes persist beyond chat session

    Example (Store Report in Note):
        Step 0: create_detailed_report(content="...", title="Q4 Analysis")
        Step 1: create_note(
            title="Q4 Analysis Report",
            body="$step0.report_content",
            folder="Work"
        )
    """
    logger.info(f"[NOTES AGENT] create_note(title={title}, folder={folder})")

    try:
        from ..automation.notes_automation import NotesAutomation
        from ..utils import load_config

        config = load_config()

        # Initialize notes automation
        notes_automation = NotesAutomation(config)

        # Create note
        result = notes_automation.create_note(title, body, folder)

        if result.get("success"):
            logger.info(f"[NOTES AGENT] ✅ Created note: {title} in folder: {folder}")
        else:
            logger.error(f"[NOTES AGENT] ❌ Failed to create note: {result.get('error_message')}")

        return result

    except Exception as e:
        logger.error(f"[NOTES AGENT] Error in create_note: {e}")
        return {
            "success": False,
            "error": True,
            "error_type": "NoteCreationError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def append_note(
    note_title: str,
    content: str,
    folder: str = "Notes"
) -> Dict[str, Any]:
    """
    Append content to an existing note (or create if doesn't exist).

    NOTES AGENT - LEVEL 1: Note Update
    Use this to add information to an existing note.

    Args:
        note_title: Title of note to append to
        content: Content to append (will be added with newline separator)
        folder: Folder containing the note (default: "Notes")

    Returns:
        Dictionary with append status:
        {
            "success": True,
            "note_title": str,
            "appended_content_length": int,
            "folder": str,
            "message": str
        }

    Example Workflow (Accumulating Information):
        Step 0: get_weather_forecast(location="NYC", timeframe="today")
        Step 1: append_note(
            note_title="Weather Journal",
            content="Today: $step0.current_temp°F, $step0.current_conditions",
            folder="Personal"
        )

    INTEGRATION PATTERN:
    - Use to accumulate daily logs or journal entries
    - Append analysis results to running notes
    - Build up information over multiple interactions
    """
    logger.info(f"[NOTES AGENT] append_note(note_title={note_title}, folder={folder})")

    try:
        from ..automation.notes_automation import NotesAutomation
        from ..utils import load_config

        config = load_config()

        # Initialize notes automation
        notes_automation = NotesAutomation(config)

        # Append to note
        result = notes_automation.append_note(note_title, content, folder)

        if result.get("success"):
            logger.info(f"[NOTES AGENT] ✅ Appended to note: {note_title}")
        else:
            logger.error(f"[NOTES AGENT] ❌ Failed to append: {result.get('error_message')}")

        return result

    except Exception as e:
        logger.error(f"[NOTES AGENT] Error in append_note: {e}")
        return {
            "success": False,
            "error": True,
            "error_type": "NoteAppendError",
            "error_message": str(e),
            "retry_possible": False
        }


@tool
def get_note(
    note_title: str,
    folder: str = "Notes"
) -> Dict[str, Any]:
    """
    Retrieve a note's content by title.

    NOTES AGENT - LEVEL 1: Note Retrieval
    Use this to read previously stored information from notes.

    Args:
        note_title: Title of note to retrieve
        folder: Folder containing the note (default: "Notes")

    Returns:
        Dictionary with note content:
        {
            "success": True,
            "note_title": str,
            "note_body": str,
            "folder": str,
            "message": str
        }

    Example Workflow (Retrieve and Summarize):
        Step 0: get_note(note_title="Meeting Notes 2024", folder="Work")
        Step 1: synthesize_content(
            source_contents=["$step0.note_body"],
            topic="Action items from meeting",
            synthesis_style="brief"
        )
        Step 2: reply_to_user(message="$step1.synthesized_content")
    """
    logger.info(f"[NOTES AGENT] get_note(note_title={note_title}, folder={folder})")

    try:
        from ..automation.notes_automation import NotesAutomation
        from ..utils import load_config

        config = load_config()

        # Initialize notes automation
        notes_automation = NotesAutomation(config)

        # Get note
        result = notes_automation.get_note(note_title, folder)

        if result.get("success"):
            logger.info(f"[NOTES AGENT] ✅ Retrieved note: {note_title}")
        else:
            logger.error(f"[NOTES AGENT] ❌ Failed to get note: {result.get('error_message')}")

        return result

    except Exception as e:
        logger.error(f"[NOTES AGENT] Error in get_note: {e}")
        return {
            "success": False,
            "error": True,
            "error_type": "NoteRetrievalError",
            "error_message": str(e),
            "retry_possible": False
        }


# Notes Agent Tool Registry
NOTES_AGENT_TOOLS = [
    create_note,
    append_note,
    get_note,
]


# Tool hierarchy documentation
NOTES_AGENT_HIERARCHY = """
NOTES AGENT TOOL HIERARCHY
==========================

LEVEL 1: Note Management
├─ create_note → Create new note with title and body
│  ├─ Persistent storage in Apple Notes
│  ├─ Organizes into folders
│  └─ Returns note_id for reference
│
├─ append_note → Add content to existing note (or create if missing)
│  ├─ Accumulates information over time
│  ├─ Useful for journals or running logs
│  └─ Auto-creates note if doesn't exist
│
└─ get_note → Retrieve note content by title
   ├─ Read previously stored information
   ├─ Can be fed to Writing Agent for processing
   └─ Returns full note body

INTEGRATION PATTERNS:

Pattern 1: Weather-Conditional Note Creation
────────────────────────────────────────────
Step 0: get_weather_forecast(location="SF", timeframe="today")
Step 1: synthesize_content(
    source_contents=["$step0.current_conditions"],
    topic="Is it sunny?",
    synthesis_style="brief"
)
Step 2: IF $step1 says "sunny" -> create_note(
    title="Outdoor Activity Reminder",
    body="Weather is sunny. Good day for outdoor plans.",
    folder="Personal"
)

Pattern 2: Store Generated Reports
──────────────────────────────────
Step 0: create_detailed_report(content="...", title="Analysis")
Step 1: create_note(
    title="Analysis Report - 2024-12-20",
    body="$step0.report_content",
    folder="Work"
)

Pattern 3: Daily Journal Accumulation
─────────────────────────────────────
Step 0: get_weather_forecast(timeframe="today")
Step 1: append_note(
    note_title="Daily Journal",
    content="Date: 2024-12-20\\nWeather: $step0.current_conditions, $step0.current_temp°F",
    folder="Personal"
)

CRITICAL PRINCIPLES:
- Notes persist beyond chat session
- Use Writing Agent to generate note content
- Conditional creation based on LLM reasoning
- NO hardcoded note content - everything LLM-generated
"""


def execute_notes_agent_tools(tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute a notes agent tool by name.

    Args:
        tool_name: Name of the tool to execute
        arguments: Tool arguments as dictionary

    Returns:
        Tool execution result
    """
    logger.info(f"[NOTES AGENT] Executing tool: {tool_name}")

    tool_map = {
        "create_note": create_note,
        "append_note": append_note,
        "get_note": get_note,
    }

    if tool_name not in tool_map:
        return {
            "error": True,
            "error_type": "UnknownTool",
            "error_message": f"Unknown notes agent tool: {tool_name}",
            "retry_possible": False
        }

    try:
        tool = tool_map[tool_name]
        result = tool.invoke(arguments)
        return result
    except Exception as e:
        logger.error(f"[NOTES AGENT] Execution error: {e}")
        return {
            "error": True,
            "error_type": "ExecutionError",
            "error_message": str(e),
            "retry_possible": False
        }
